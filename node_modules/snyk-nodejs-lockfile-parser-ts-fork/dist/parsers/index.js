"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPnpmWorkspaces = exports.getYarnWorkspaces = exports.createDepTreeDepFromDep = exports.findPnpmLink = exports.getTopLevelDeps = exports.parseWorkspaceFile = exports.parseManifestFile = exports.LockfileType = exports.Scope = void 0;
const errors_1 = require("../errors");
const yaml = require("js-yaml");
var Scope;
(function (Scope) {
    Scope["prod"] = "prod";
    Scope["dev"] = "dev";
})(Scope = exports.Scope || (exports.Scope = {}));
var LockfileType;
(function (LockfileType) {
    LockfileType["npm"] = "npm";
    LockfileType["npm7"] = "npm7";
    LockfileType["yarn"] = "yarn";
    LockfileType["yarn2"] = "yarn2";
    LockfileType["pnpm"] = "pnpm";
})(LockfileType = exports.LockfileType || (exports.LockfileType = {}));
function parseManifestFile(manifestFileContents) {
    try {
        return JSON.parse(manifestFileContents);
    }
    catch (e) {
        const error = e;
        throw new errors_1.InvalidUserInputError('package.json parsing failed with error ' + error.message);
    }
}
exports.parseManifestFile = parseManifestFile;
function parseWorkspaceFile(manifestFileContents) {
    try {
        const workspaceFile = yaml.load(manifestFileContents, {
            json: true,
        });
        return workspaceFile;
    }
    catch (e) {
        const error = e;
        throw new errors_1.InvalidUserInputError('pnpm-workspace.yaml parsing failed with error ' + error.message);
    }
}
exports.parseWorkspaceFile = parseWorkspaceFile;
function getTopLevelDeps(targetFile, includeDev, lockfile, workspace) {
    const dependencies = [];
    let pnpmDependencies;
    let pnpmDevDep;
    if (lockfile.type === 'pnpm') {
        const pnpmResult = getPnpmTopLevel(lockfile, workspace, includeDev);
        return pnpmResult;
    }
    else {
        const dependenciesIterator = Object.entries(Object.assign(Object.assign(Object.assign({}, targetFile.dependencies), (includeDev ? targetFile.devDependencies : null)), (targetFile.optionalDependencies || {})));
        for (const [name, version] of dependenciesIterator) {
            dependencies.push({
                dev: includeDev && targetFile.devDependencies
                    ? !!targetFile.devDependencies[name]
                    : false,
                name,
                version,
            });
        }
        //  }
        // Only include peerDependencies if using npm and npm is at least
        // version 7 as npm v7 automatically installs peerDependencies
        if (lockfile.type === LockfileType.npm7 && targetFile.peerDependencies) {
            for (const [name, version] of Object.entries(targetFile.peerDependencies)) {
                dependencies.push({
                    name,
                    version,
                });
            }
        }
    }
    return {
        dependenciesArray: dependencies,
        pnpmDependencies: pnpmDependencies,
        pnpmDevDeps: pnpmDevDep,
    };
}
exports.getTopLevelDeps = getTopLevelDeps;
// pnpm have link in the lockfile  ie: '@helpers/enzyme-redux': link:../../helpers/enzyme-redux
// those can link to any other package in the project
// Find the path the the link package
// to extra the dev dependencies from it
function findPnpmLink(linkPath, workspace) {
    // build a new linkPath with the useful info from linkPath (removing all the ..)
    const list = linkPath.split('/');
    const packagesNameList = workspace.split('/');
    const newList = [];
    let up = 0;
    // count how many file up we need to go
    list.forEach((filename) => {
        if (filename.includes('..')) {
            up = up + 1;
        }
    });
    // add current package name if needed
    // if up is smaller than packagesNameList length
    // the link is out of the current package
    if (up <= packagesNameList.length) {
        for (let index = 0; index < up; index++) {
            newList.push(packagesNameList[index]);
        }
    }
    // add the linked folder name
    list.forEach((filename) => {
        if (!(filename.includes('..') || filename.includes('link:..'))) {
            newList.push(filename);
        }
    });
    const newPath = newList.join('/');
    return newPath;
}
exports.findPnpmLink = findPnpmLink;
function createDepTreeDepFromDep(dep) {
    return {
        labels: {
            scope: dep.dev ? Scope.dev : Scope.prod,
        },
        name: dep.name,
        version: dep.version,
    };
}
exports.createDepTreeDepFromDep = createDepTreeDepFromDep;
function getYarnWorkspaces(targetFile) {
    try {
        const packageJson = parseManifestFile(targetFile);
        if (!!packageJson.workspaces && !!packageJson.private) {
            const workspacesPackages = packageJson.workspaces;
            const workspacesAlternateConfigPackages = packageJson.workspaces
                .packages;
            return [...(workspacesAlternateConfigPackages || workspacesPackages)];
        }
        return false;
    }
    catch (e) {
        const error = e;
        throw new errors_1.InvalidUserInputError('package.json parsing failed with ' + `error ${error.message}`);
    }
}
exports.getYarnWorkspaces = getYarnWorkspaces;
function getPnpmWorkspaces(targetFile) {
    try {
        const workspaceFile = parseWorkspaceFile(targetFile);
        if (workspaceFile.packages) {
            const workspacesPackages = workspaceFile.packages;
            return [...workspacesPackages];
        }
        return false;
    }
    catch (e) {
        const error = e;
        throw new errors_1.InvalidUserInputError('package.json parsing failed with ' + `error ${error.message}`);
    }
}
exports.getPnpmWorkspaces = getPnpmWorkspaces;
function getPnpmTopLevel(lockfile, workspace, includeDev) {
    const pnpmLock = lockfile;
    const dependencies = [];
    let pnpmDependencies;
    let pnpmDevDep;
    if (workspace) {
        // If this is a workspace project then the top level dependencies will be
        // specified in importers[package_name]
        for (const [PackageName, dep] of Object.entries(pnpmLock.importers)) {
            // To make an accurate tree and avoid infinite loop we need to use only
            // the top level deps of package we are building a tree for
            if (PackageName.includes(workspace)) {
                if (dep.dependencies != undefined) {
                    for (const [depKeys, depValue] of Object.entries(dep.dependencies)) {
                        // If the package needs an other package it will look like
                        // packages/packagesName: link../packageName
                        // We delete the link and replace with the appropriate package deps
                        if (depValue.includes('link:..')) {
                            const linkedPkgName = findPnpmLink(depValue, workspace);
                            delete dep.dependencies[depKeys];
                            if (pnpmLock.importers[linkedPkgName]) {
                                dep.dependencies = Object.assign(Object.assign({}, dep.dependencies), pnpmLock.importers[linkedPkgName].dependencies);
                            }
                        }
                    }
                }
                // Same as above but for devDependencies
                if (dep.devDependencies != undefined) {
                    for (const [depKeys, depValue] of Object.entries(dep.devDependencies)) {
                        if (depValue.includes('link:..')) {
                            const linkedPkgName = findPnpmLink(depValue, workspace);
                            delete dep.devDependencies[depKeys];
                            if (pnpmLock.importers[linkedPkgName]) {
                                dep.devDependencies = Object.assign(Object.assign({}, dep.devDependencies), pnpmLock.importers[linkedPkgName].devDependencies);
                            }
                        }
                    }
                }
                // Getting the top level dependencies details
                const dependenciesIterator = Object.entries(Object.assign(Object.assign({}, dep.dependencies), (includeDev ? dep.devDependencies : null)));
                // in a workspace configuration
                // top level deps are empty for pnpm
                // assigning it here to be reused later
                // while creating the depMap
                pnpmDependencies = dep.dependencies;
                pnpmDevDep = dep.devDependencies;
                // eslint-disable-next-line prefer-const
                for (let [name, version] of dependenciesIterator) {
                    // Detect packages added from local
                    // Those don't have a proper version
                    // (ie: rush, zip the project and add it as a package)
                    // https://pnpm.io/cli/add#install-from-local-file-system
                    if (version && version.includes('file')) {
                        version = '0.0.0';
                    }
                    dependencies.push({
                        dev: includeDev && pnpmLock.devDependencies
                            ? !!pnpmLock.devDependencies[name]
                            : false,
                        name,
                        version,
                    });
                }
            }
        }
    }
    else {
        // Getting the top level dependencies details
        const dependenciesIterator = Object.entries(Object.assign(Object.assign({}, pnpmLock.dependencies), (includeDev ? pnpmLock.devDependencies : null)));
        // Detect packages added from local
        // Those don't have a proper version
        // (ie: rush, zip the project and add it as a package)
        // https://pnpm.io/cli/add#install-from-local-file-system
        // eslint-disable-next-line prefer-const
        for (let [name, version] of dependenciesIterator) {
            if (version && version.includes('file:')) {
                version = '0.0.0';
            }
            dependencies.push({
                dev: includeDev && pnpmLock.devDependencies
                    ? !!pnpmLock.devDependencies[name]
                    : false,
                name,
                version,
            });
        }
    }
    return {
        dependenciesArray: dependencies,
        pnpmDependencies: pnpmDependencies,
        pnpmDevDeps: pnpmDevDep,
    };
}
//# sourceMappingURL=index.js.map