"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPnpmWorkspaces = exports.getYarnWorkspaces = exports.createDepTreeDepFromDep = exports.getTopLevelDeps = exports.parseWorkspaceFile = exports.parseManifestFile = exports.LockfileType = exports.Scope = void 0;
const errors_1 = require("../errors");
const yaml = require("js-yaml");
var Scope;
(function (Scope) {
    Scope["prod"] = "prod";
    Scope["dev"] = "dev";
})(Scope = exports.Scope || (exports.Scope = {}));
var LockfileType;
(function (LockfileType) {
    LockfileType["npm"] = "npm";
    LockfileType["npm7"] = "npm7";
    LockfileType["yarn"] = "yarn";
    LockfileType["yarn2"] = "yarn2";
    LockfileType["pnpm"] = "pnpm";
})(LockfileType = exports.LockfileType || (exports.LockfileType = {}));
function parseManifestFile(manifestFileContents) {
    try {
        return JSON.parse(manifestFileContents);
    }
    catch (e) {
        throw new errors_1.InvalidUserInputError('package.json parsing failed with error ' + e.message);
    }
}
exports.parseManifestFile = parseManifestFile;
function parseWorkspaceFile(manifestFileContents) {
    try {
        const workspaceFile = yaml.load(manifestFileContents, {
            json: true,
        });
        return workspaceFile;
    }
    catch (e) {
        throw new errors_1.InvalidUserInputError('pnpm-workspace.yaml parsing failed with error ' + e.message);
    }
}
exports.parseWorkspaceFile = parseWorkspaceFile;
function getTopLevelDeps(targetFile, includeDev, lockfile, workspace) {
    const dependencies = [];
    if (lockfile.type === 'pnpm') {
        const pnpmLock = lockfile;
        let topLevelDeps = {};
        if (workspace) {
            // If this is a workspace project then the top level dependencies will be
            // specified in importers[package_name]
            for (const [PackageName, dep] of Object.entries(pnpmLock.importers)) {
                // To make an accurate tree and avoid infinite loop we need to use only
                // the top level deps of package we are building a tree for
                if (PackageName.includes(workspace)) {
                    if (dep.dependencies != undefined) {
                        for (const [depKeys, depValue] of Object.entries(dep.dependencies)) {
                            // If the package needs an other package it will look like
                            // packages/packagesName: link../packageName
                            // We delete the link and replace with the appropriate package deps
                            if (depValue.includes('link:..')) {
                                const linked = depValue.split('/')[1];
                                const linkedPkgName = `packages/${linked}`;
                                delete dep.dependencies[depKeys];
                                dep.dependencies = Object.assign(Object.assign({}, dep.dependencies), pnpmLock.importers[linkedPkgName].dependencies);
                            }
                        }
                    }
                    // Same as above but for devDependencies
                    if (dep.devDependencies != undefined) {
                        for (const [depKeys, depValue] of Object.entries(dep.devDependencies)) {
                            if (depValue.includes('link:..')) {
                                const linked = depValue.split('/')[1];
                                const linkedPkgName = `packages/${linked}`;
                                delete dep.devDependencies[depKeys];
                                dep.devDependencies = Object.assign(Object.assign({}, dep.devDependencies), pnpmLock.importers[linkedPkgName].devDependencies);
                            }
                        }
                    }
                    // Getting the top level dependencies details
                    const dependenciesIterator = Object.entries(Object.assign(Object.assign({}, dep.dependencies), (includeDev ? dep.devDependencies : null)));
                    for (const [name, version] of dependenciesIterator) {
                        dependencies.push({
                            dev: includeDev && pnpmLock.devDependencies
                                ? !!pnpmLock.devDependencies[name]
                                : false,
                            name,
                            version,
                        });
                    }
                }
            }
        }
        else {
            // Getting the top level dependencies details
            const dependenciesIterator = Object.entries(Object.assign(Object.assign({}, pnpmLock.dependencies), (includeDev ? pnpmLock.devDependencies : null)));
            for (const [name, version] of dependenciesIterator) {
                dependencies.push({
                    dev: includeDev && pnpmLock.devDependencies
                        ? !!pnpmLock.devDependencies[name]
                        : false,
                    name,
                    version,
                });
            }
        }
    }
    else {
        const dependenciesIterator = Object.entries(Object.assign(Object.assign(Object.assign({}, targetFile.dependencies), (includeDev ? targetFile.devDependencies : null)), (targetFile.optionalDependencies || {})));
        for (const [name, version] of dependenciesIterator) {
            dependencies.push({
                dev: includeDev && targetFile.devDependencies
                    ? !!targetFile.devDependencies[name]
                    : false,
                name,
                version,
            });
        }
        //  }
        // Only include peerDependencies if using npm and npm is at least
        // version 7 as npm v7 automatically installs peerDependencies
        if (lockfile.type === LockfileType.npm7 && targetFile.peerDependencies) {
            for (const [name, version] of Object.entries(targetFile.peerDependencies)) {
                dependencies.push({
                    name,
                    version,
                });
            }
        }
    }
    return dependencies;
}
exports.getTopLevelDeps = getTopLevelDeps;
function createDepTreeDepFromDep(dep) {
    return {
        labels: {
            scope: dep.dev ? Scope.dev : Scope.prod,
        },
        name: dep.name,
        version: dep.version,
    };
}
exports.createDepTreeDepFromDep = createDepTreeDepFromDep;
function getYarnWorkspaces(targetFile) {
    try {
        const packageJson = parseManifestFile(targetFile);
        if (!!packageJson.workspaces && !!packageJson.private) {
            const workspacesPackages = packageJson.workspaces;
            const workspacesAlternateConfigPackages = packageJson.workspaces
                .packages;
            return [...(workspacesAlternateConfigPackages || workspacesPackages)];
        }
        return false;
    }
    catch (e) {
        throw new errors_1.InvalidUserInputError('package.json parsing failed with ' + `error ${e.message}`);
    }
}
exports.getYarnWorkspaces = getYarnWorkspaces;
function getPnpmWorkspaces(targetFile) {
    try {
        const workspaceFile = parseWorkspaceFile(targetFile);
        if (workspaceFile.packages) {
            const workspacesPackages = workspaceFile.packages;
            return [...workspacesPackages];
        }
        return false;
    }
    catch (e) {
        throw new errors_1.InvalidUserInputError('package.json parsing failed with ' + `error ${e.message}`);
    }
}
exports.getPnpmWorkspaces = getPnpmWorkspaces;
//# sourceMappingURL=index.js.map