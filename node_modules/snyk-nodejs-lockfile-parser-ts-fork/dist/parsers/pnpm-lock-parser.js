"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpmPackageLockParser = void 0;
const yaml = require("js-yaml");
const debug_1 = require("debug");
const index_1 = require("./index");
const errors_1 = require("../errors");
const lock_parser_base_1 = require("./lock-parser-base");
const config_1 = require("../config");
class PnpmPackageLockParser extends lock_parser_base_1.LockParserBase {
    constructor() {
        super(index_1.LockfileType.pnpm, config_1.config.PNPM_TREE_SIZE_LIMIT);
    }
    parseLockFile(lockFileContents) {
        try {
            const pnpmLock = yaml.load(lockFileContents, {
                json: true,
            });
            const lockfile = Object.assign(Object.assign({}, pnpmLock), { type: index_1.LockfileType.pnpm });
            return lockfile;
            1;
        }
        catch (e) {
            const error = e;
            throw new errors_1.InvalidUserInputError(`pnpm-lock.yml parsing failed with error ${error.message}`);
        }
    }
    async getDependencyTree(manifestFile, lockfile, includeDev = false, strict = true, workspace) {
        const dependencyTree = await super.getDependencyTree(manifestFile, lockfile, includeDev, strict, workspace);
        const meta = {
            // TODO: what versions do we support? Are older versions completely different?
            // do we need to validate and show an error when it is unsupported version?
            lockfileVersion: lockfile.lockfileVersion,
            packageManager: 'pnpm',
        };
        const depTreeWithMeta = Object.assign(Object.assign({}, dependencyTree), { meta: Object.assign(Object.assign({}, dependencyTree.meta), meta) });
        return depTreeWithMeta;
    }
    getDepMap(lockfile, pnpmTopLevelDeps, pnpmTopLevelDevDeps) {
        const debug = (0, debug_1.default)('Snyk');
        const pnpmLock = lockfile;
        const depMap = {};
        let FirstTransitives = {};
        // if pnpmTopLevelDeps or pnpmTopLevelDevDeps means this is  workspace
        // use the the topLevel calculated before to generate the FirstTransitives
        if (pnpmTopLevelDeps) {
            pnpmLock.dependencies = pnpmTopLevelDeps;
        }
        if (pnpmTopLevelDevDeps) {
            pnpmLock.devDependencies = pnpmTopLevelDevDeps;
        }
        FirstTransitives = Object.assign(Object.assign(Object.assign({}, FirstTransitives), pnpmLock.dependencies), pnpmLock.devDependencies);
        const startingDependenciesData = {};
        const allDependenciesData = pnpmLock.packages;
        if (!FirstTransitives || !allDependenciesData)
            return {};
        // Building the first dependencies data with the topLevel dependencies
        // to start the building the depMap
        for (const [depName, dep] of Object.entries(FirstTransitives)) {
            let transitiveName;
            const deptmp = dep;
            // detect packages added from local (ie: rush, zip the project and add it as a package)
            // https://pnpm.io/cli/add#install-from-local-file-system
            // don't respect the same pattern
            // in the dependencies list it looks like : '@rush-temp/goof': file:projects/goof.tgz
            // and in the packages list : file:projects/goof.tgz
            // see example pnpm/pnpm-rush-simple
            if (deptmp.includes('file:')) {
                // need to keep both depName dep string for later
                transitiveName = `${depName}${dep}`;
                startingDependenciesData[transitiveName] = allDependenciesData[deptmp];
            }
            else {
                transitiveName = `/${depName}/${dep}`;
                startingDependenciesData[transitiveName] =
                    allDependenciesData[transitiveName];
            }
        }
        const flattenLockfileRec = (lockfileDeps, path) => {
            for (const [depName, dep] of Object.entries(lockfileDeps)) {
                const dependencyName = this.getName(depName);
                const packageVersion = this.getVersion(depName);
                const depNode = {
                    labels: {
                        scope: dep.dev ? index_1.Scope.dev : index_1.Scope.prod,
                    },
                    name: dependencyName,
                    requires: [],
                    version: packageVersion,
                };
                if (dep.dependencies) {
                    const transitives = dep.dependencies || {};
                    depNode.requires = Object.keys(transitives);
                }
                const depPath = [...path, dependencyName];
                const depKey = depPath.join(this.pathDelimiter);
                depMap[depKey] = depNode;
                if (dep.dependencies) {
                    const transitives = dep.dependencies;
                    const transitiveMap = {};
                    for (const t of Object.keys(transitives)) {
                        const depName = `/${t}/${transitives[t]}`;
                        if (!depPath.includes(t)) {
                            transitiveMap[depName] = allDependenciesData[depName];
                        }
                        else {
                            debug('Info: Already have this transitive ' + t + ' in the path');
                        }
                    }
                    if (transitiveMap === {}) {
                        return;
                    }
                    else {
                        flattenLockfileRec(transitiveMap, depPath);
                    }
                }
            }
        };
        flattenLockfileRec(startingDependenciesData || {}, []);
        return depMap;
    }
    getDepTreeKey(dep) {
        return dep.name;
    }
    getName(depName) {
        if (depName.includes('file:')) {
            return depName.split('file:')[0];
        }
        const fields = depName.split('/');
        fields.pop();
        return fields.join('/').substring(1);
    }
    getVersion(depName) {
        if (depName.includes('file:')) {
            // setting default value for tarball file
            return '0.0.0';
        }
        const fields = depName.split('/');
        return fields[fields.length - 1];
    }
}
exports.PnpmPackageLockParser = PnpmPackageLockParser;
//# sourceMappingURL=pnpm-lock-parser.js.map