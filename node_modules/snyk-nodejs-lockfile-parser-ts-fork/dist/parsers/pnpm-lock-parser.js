"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpmPackageLockParser = void 0;
const yaml = require("js-yaml");
const index_1 = require("./index");
const errors_1 = require("../errors");
const lock_parser_base_1 = require("./lock-parser-base");
const config_1 = require("../config");
class PnpmPackageLockParser extends lock_parser_base_1.LockParserBase {
    constructor() {
        super(index_1.LockfileType.pnpm, config_1.config.PNPM_TREE_SIZE_LIMIT);
    }
    parseLockFile(lockFileContents) {
        try {
            const pnpmLock = yaml.load(lockFileContents, {
                json: true,
            });
            const lockfile = Object.assign(Object.assign({}, pnpmLock), { type: index_1.LockfileType.pnpm });
            return lockfile;
        }
        catch (e) {
            throw new errors_1.InvalidUserInputError(`pnpm-lock.yml parsing failed with error ${e.message}`);
        }
    }
    async getDependencyTree(manifestFile, lockfile, includeDev = false, strict = true, workspace) {
        const dependencyTree = await super.getDependencyTree(manifestFile, lockfile, includeDev, strict, workspace);
        const meta = {
            // TODO: what versions do we support? Are older versions completely different?
            // do we need to validate and show an error when it is unsupported version?
            lockfileVersion: lockfile.lockfileVersion,
            packageManager: 'pnpm',
        };
        const depTreeWithMeta = Object.assign(Object.assign({}, dependencyTree), { meta: Object.assign(Object.assign({}, dependencyTree.meta), meta) });
        return depTreeWithMeta;
    }
    getDepMap(lockfile, workspace) {
        const pnpmLock = lockfile;
        const depMap = {};
        let FirstTransitives = {};
        if (workspace) {
            // If this is a workspace project then the top level dependencies will be
            // specified in importers[package_name]
            for (const [PackageName, dep] of Object.entries(pnpmLock.importers)) {
                // To make an accurate tree and avoid infinite loop we need to use only
                // the top level deps of package we are building a tree for
                if (PackageName.includes(workspace)) {
                    if (dep.dependencies != undefined) {
                        for (const [depKeys, depValue] of Object.entries(dep.dependencies)) {
                            // If the package needs an other package it will look like
                            // packages/packagesName: link../packageName
                            // We delete the link and replace with the appropriate package deps
                            if (depValue.includes('link:..')) {
                                const linked = depValue.split('/')[1];
                                const linkedPkgName = `packages/${linked}`;
                                delete dep.dependencies[depKeys];
                                dep.dependencies = Object.assign(Object.assign({}, dep.dependencies), pnpmLock.importers[linkedPkgName].dependencies);
                            }
                        }
                    }
                    // Same as above but for devDependencies
                    if (dep.devDependencies != undefined) {
                        for (const [depKeys, depValue] of Object.entries(dep.devDependencies)) {
                            if (depValue.includes('link:..')) {
                                const linked = depValue.split('/')[1];
                                const linkedPkgName = `packages/${linked}`;
                                delete dep.devDependencies[depKeys];
                                dep.devDependencies = Object.assign(Object.assign({}, dep.devDependencies), pnpmLock.importers[linkedPkgName].devDependencies);
                            }
                        }
                    }
                    // Getting of the topLevel dependencies
                    FirstTransitives = Object.assign(Object.assign(Object.assign({}, FirstTransitives), dep.dependencies), dep.devDependencies);
                }
            }
        }
        else {
            FirstTransitives = Object.assign(Object.assign(Object.assign({}, FirstTransitives), pnpmLock.dependencies), pnpmLock.devDependencies);
        }
        const startingDependenciesData = {};
        const allDependenciesData = pnpmLock.packages;
        if (!FirstTransitives || !allDependenciesData)
            return {};
        // Building the first dependencies data with the topLevel dependencies
        // to start the building the depMap
        for (const [depName, dep] of Object.entries(FirstTransitives)) {
            const transitiveName = `/${depName}/${dep}`;
            startingDependenciesData[transitiveName] =
                allDependenciesData[transitiveName];
        }
        const flattenLockfileRec = (lockfileDeps, path) => {
            for (const [depName, dep] of Object.entries(lockfileDeps)) {
                const dependencyName = this.getName(depName);
                const packageVersion = this.getVersion(depName);
                const depNode = {
                    labels: {
                        scope: dep.dev ? index_1.Scope.dev : index_1.Scope.prod,
                    },
                    name: dependencyName,
                    requires: [],
                    version: packageVersion,
                };
                if (dep.dependencies) {
                    const transitives = dep.dependencies || {};
                    depNode.requires = Object.keys(transitives);
                }
                const depPath = [...path, dependencyName];
                const depKey = depPath.join(this.pathDelimiter);
                if (depMap[depKey]) {
                    //console.log('I already have this one : ' + depKey, depPath );
                } //else {
                depMap[depKey] = depNode;
                //}
                if (dep.dependencies) {
                    const transitives = dep.dependencies;
                    const transitiveMap = {};
                    for (const t of Object.keys(transitives)) {
                        const depName = `/${t}/${transitives[t]}`;
                        transitiveMap[depName] = allDependenciesData[depName];
                    }
                    flattenLockfileRec(transitiveMap, depPath);
                }
            }
        };
        flattenLockfileRec(startingDependenciesData || {}, []);
        return depMap;
    }
    getDepTreeKey(dep) {
        return dep.name;
    }
    getName(depName) {
        const fields = depName.split('/');
        return fields[1];
    }
    getVersion(depName) {
        const fields = depName.split('/');
        return fields[fields.length - 1];
    }
}
exports.PnpmPackageLockParser = PnpmPackageLockParser;
//# sourceMappingURL=pnpm-lock-parser.js.map