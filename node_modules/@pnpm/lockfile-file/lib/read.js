"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLockfileObject = exports.readWantedLockfile = exports.readWantedLockfileAndAutofixConflicts = exports.readCurrentLockfile = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const constants_1 = require("@pnpm/constants");
const error_1 = __importDefault(require("@pnpm/error"));
const types_1 = require("@pnpm/types");
const comver_to_semver_1 = __importDefault(require("comver-to-semver"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const semver_1 = __importDefault(require("semver"));
const strip_bom_1 = __importDefault(require("strip-bom"));
const errors_1 = require("./errors");
const gitMergeFile_1 = require("./gitMergeFile");
const logger_1 = __importDefault(require("./logger"));
async function readCurrentLockfile(virtualStoreDir, opts) {
    const lockfilePath = path_1.default.join(virtualStoreDir, 'lock.yaml');
    return (await _read(lockfilePath, virtualStoreDir, opts)).lockfile;
}
exports.readCurrentLockfile = readCurrentLockfile;
async function readWantedLockfileAndAutofixConflicts(pkgPath, opts) {
    const lockfilePath = path_1.default.join(pkgPath, constants_1.WANTED_LOCKFILE);
    return _read(lockfilePath, pkgPath, { ...opts, autofixMergeConflicts: true });
}
exports.readWantedLockfileAndAutofixConflicts = readWantedLockfileAndAutofixConflicts;
async function readWantedLockfile(pkgPath, opts) {
    const lockfilePath = path_1.default.join(pkgPath, constants_1.WANTED_LOCKFILE);
    return (await _read(lockfilePath, pkgPath, opts)).lockfile;
}
exports.readWantedLockfile = readWantedLockfile;
async function _read(lockfilePath, prefix, opts) {
    var _a;
    let lockfileRawContent;
    try {
        lockfileRawContent = strip_bom_1.default(await fs_1.promises.readFile(lockfilePath, 'utf8'));
    }
    catch (err) {
        if (err.code !== 'ENOENT') {
            throw err;
        }
        return {
            lockfile: null,
            hadConflicts: false,
        };
    }
    let lockfile;
    let hadConflicts;
    try {
        lockfile = js_yaml_1.default.load(lockfileRawContent);
        hadConflicts = false;
    }
    catch (err) {
        if (!opts.autofixMergeConflicts || !gitMergeFile_1.isDiff(lockfileRawContent)) {
            throw new error_1.default('BROKEN_LOCKFILE', `The lockfile at "${lockfilePath}" is broken: ${err.message}`);
        }
        hadConflicts = true;
        lockfile = gitMergeFile_1.autofixMergeConflicts(lockfileRawContent);
        logger_1.default.info({
            message: `Merge conflict detected in ${constants_1.WANTED_LOCKFILE} and successfully merged`,
            prefix: path_1.default.dirname(lockfilePath),
        });
    }
    /* eslint-disable @typescript-eslint/dot-notation */
    if (typeof (lockfile === null || lockfile === void 0 ? void 0 : lockfile['specifiers']) !== 'undefined') {
        lockfile.importers = {
            '.': {
                specifiers: lockfile['specifiers'],
            },
        };
        delete lockfile.specifiers;
        for (const depType of types_1.DEPENDENCIES_FIELDS) {
            if (lockfile[depType] != null) {
                lockfile.importers['.'][depType] = lockfile[depType];
                delete lockfile[depType];
            }
        }
    }
    if (lockfile) {
        const lockfileSemver = comver_to_semver_1.default(((_a = lockfile.lockfileVersion) !== null && _a !== void 0 ? _a : 0).toString());
        /* eslint-enable @typescript-eslint/dot-notation */
        if (typeof opts.wantedVersion !== 'number' || semver_1.default.major(lockfileSemver) === semver_1.default.major(comver_to_semver_1.default(opts.wantedVersion.toString()))) {
            if (typeof opts.wantedVersion === 'number' && semver_1.default.gt(lockfileSemver, comver_to_semver_1.default(opts.wantedVersion.toString()))) {
                logger_1.default.warn({
                    message: `Your ${constants_1.WANTED_LOCKFILE} was generated by a newer version of pnpm. ` +
                        `It is a compatible version but it might get downgraded to version ${opts.wantedVersion}`,
                    prefix,
                });
            }
            return { lockfile: lockfile, hadConflicts };
        }
    }
    if (opts.ignoreIncompatible) {
        logger_1.default.warn({
            message: `Ignoring not compatible lockfile at ${lockfilePath}`,
            prefix,
        });
        return { lockfile: null, hadConflicts: false };
    }
    throw new errors_1.LockfileBreakingChangeError(lockfilePath);
}
function createLockfileObject(importerIds, opts) {
    const importers = importerIds.reduce((acc, importerId) => {
        acc[importerId] = {
            dependencies: {},
            specifiers: {},
        };
        return acc;
    }, {});
    return {
        importers,
        lockfileVersion: opts.lockfileVersion || constants_1.LOCKFILE_VERSION,
    };
}
exports.createLockfileObject = createLockfileObject;
//# sourceMappingURL=read.js.map