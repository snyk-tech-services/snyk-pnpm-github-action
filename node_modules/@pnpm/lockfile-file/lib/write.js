"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeLockfile = exports.writeCurrentLockfile = exports.writeWantedLockfile = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const types_1 = require("@pnpm/types");
const constants_1 = require("@pnpm/constants");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const equals_1 = __importDefault(require("ramda/src/equals"));
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const write_file_atomic_1 = __importDefault(require("write-file-atomic"));
const logger_1 = __importDefault(require("./logger"));
const sortLockfileKeys_1 = require("./sortLockfileKeys");
async function writeFileAtomic(filename, data) {
    return new Promise((resolve, reject) => write_file_atomic_1.default(filename, data, {}, (err) => (err != null) ? reject(err) : resolve()));
}
const LOCKFILE_YAML_FORMAT = {
    blankLines: true,
    lineWidth: 1000,
    noCompatMode: true,
    noRefs: true,
    sortKeys: false,
};
async function writeWantedLockfile(pkgPath, wantedLockfile, opts) {
    return writeLockfile(constants_1.WANTED_LOCKFILE, pkgPath, wantedLockfile, opts);
}
exports.writeWantedLockfile = writeWantedLockfile;
async function writeCurrentLockfile(virtualStoreDir, currentLockfile, opts) {
    await fs_1.promises.mkdir(virtualStoreDir, { recursive: true });
    return writeLockfile('lock.yaml', virtualStoreDir, currentLockfile, opts);
}
exports.writeCurrentLockfile = writeCurrentLockfile;
async function writeLockfile(lockfileFilename, pkgPath, wantedLockfile, opts) {
    const lockfilePath = path_1.default.join(pkgPath, lockfileFilename);
    // empty lockfile is not saved
    if (isEmptyLockfile(wantedLockfile)) {
        return rimraf_1.default(lockfilePath);
    }
    const yamlDoc = yamlStringify(wantedLockfile, (opts === null || opts === void 0 ? void 0 : opts.forceSharedFormat) === true);
    return writeFileAtomic(lockfilePath, yamlDoc);
}
function yamlStringify(lockfile, forceSharedFormat) {
    let normalizedLockfile = normalizeLockfile(lockfile, forceSharedFormat);
    normalizedLockfile = sortLockfileKeys_1.sortLockfileKeys(normalizedLockfile);
    return js_yaml_1.default.dump(normalizedLockfile, LOCKFILE_YAML_FORMAT);
}
function isEmptyLockfile(lockfile) {
    return Object.values(lockfile.importers).every((importer) => { var _a, _b; return isEmpty_1.default((_a = importer.specifiers) !== null && _a !== void 0 ? _a : {}) && isEmpty_1.default((_b = importer.dependencies) !== null && _b !== void 0 ? _b : {}); });
}
function normalizeLockfile(lockfile, forceSharedFormat) {
    let lockfileToSave;
    if (!forceSharedFormat && equals_1.default(Object.keys(lockfile.importers), ['.'])) {
        lockfileToSave = {
            ...lockfile,
            ...lockfile.importers['.'],
        };
        delete lockfileToSave.importers;
        for (const depType of types_1.DEPENDENCIES_FIELDS) {
            if (isEmpty_1.default(lockfileToSave[depType])) {
                delete lockfileToSave[depType];
            }
        }
        if (isEmpty_1.default(lockfileToSave.packages) || (lockfileToSave.packages == null)) {
            delete lockfileToSave.packages;
        }
    }
    else {
        lockfileToSave = {
            ...lockfile,
            importers: Object.keys(lockfile.importers).reduce((acc, alias) => {
                var _a, _b;
                const importer = lockfile.importers[alias];
                const normalizedImporter = {
                    specifiers: (_a = importer.specifiers) !== null && _a !== void 0 ? _a : {},
                };
                for (const depType of types_1.DEPENDENCIES_FIELDS) {
                    if (!isEmpty_1.default((_b = importer[depType]) !== null && _b !== void 0 ? _b : {})) {
                        normalizedImporter[depType] = importer[depType];
                    }
                }
                acc[alias] = normalizedImporter;
                return acc;
            }, {}),
        };
        if (isEmpty_1.default(lockfileToSave.packages) || (lockfileToSave.packages == null)) {
            delete lockfileToSave.packages;
        }
    }
    if ((lockfileToSave.overrides != null) && isEmpty_1.default(lockfileToSave.overrides)) {
        delete lockfileToSave.overrides;
    }
    if (lockfileToSave.neverBuiltDependencies != null) {
        if (isEmpty_1.default(lockfileToSave.neverBuiltDependencies)) {
            delete lockfileToSave.neverBuiltDependencies;
        }
        else {
            lockfileToSave.neverBuiltDependencies = lockfileToSave.neverBuiltDependencies.sort();
        }
    }
    if (!lockfileToSave.packageExtensionsChecksum) {
        delete lockfileToSave.packageExtensionsChecksum;
    }
    return lockfileToSave;
}
exports.normalizeLockfile = normalizeLockfile;
async function writeLockfiles(opts) {
    const wantedLockfilePath = path_1.default.join(opts.wantedLockfileDir, constants_1.WANTED_LOCKFILE);
    const currentLockfilePath = path_1.default.join(opts.currentLockfileDir, 'lock.yaml');
    // empty lockfile is not saved
    if (isEmptyLockfile(opts.wantedLockfile)) {
        await Promise.all([
            rimraf_1.default(wantedLockfilePath),
            rimraf_1.default(currentLockfilePath),
        ]);
        return;
    }
    const forceSharedFormat = (opts === null || opts === void 0 ? void 0 : opts.forceSharedFormat) === true;
    const yamlDoc = yamlStringify(opts.wantedLockfile, forceSharedFormat);
    // in most cases the `pnpm-lock.yaml` and `node_modules/.pnpm-lock.yaml` are equal
    // in those cases the YAML document can be stringified only once for both files
    // which is more efficient
    if (opts.wantedLockfile === opts.currentLockfile) {
        await Promise.all([
            writeFileAtomic(wantedLockfilePath, yamlDoc),
            (async () => {
                await fs_1.promises.mkdir(path_1.default.dirname(currentLockfilePath), { recursive: true });
                await writeFileAtomic(currentLockfilePath, yamlDoc);
            })(),
        ]);
        return;
    }
    logger_1.default.debug({
        message: `\`${constants_1.WANTED_LOCKFILE}\` differs from \`${path_1.default.relative(opts.wantedLockfileDir, currentLockfilePath)}\``,
        prefix: opts.wantedLockfileDir,
    });
    const currentYamlDoc = yamlStringify(opts.currentLockfile, forceSharedFormat);
    await Promise.all([
        writeFileAtomic(wantedLockfilePath, yamlDoc),
        (async () => {
            await fs_1.promises.mkdir(path_1.default.dirname(currentLockfilePath), { recursive: true });
            await writeFileAtomic(currentLockfilePath, currentYamlDoc);
        })(),
    ]);
}
exports.default = writeLockfiles;
//# sourceMappingURL=write.js.map