"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchError = void 0;
class PnpmError extends Error {
    constructor(code, message, opts) {
        super(message);
        this.code = `ERR_PNPM_${code}`;
        this.hint = opts === null || opts === void 0 ? void 0 : opts.hint;
        this.attempts = opts === null || opts === void 0 ? void 0 : opts.attempts;
    }
}
exports.default = PnpmError;
class FetchError extends PnpmError {
    constructor(request, response, hint) {
        const message = `GET ${request.url}: ${response.statusText} - ${response.status}`;
        const authHeaderValue = request.authHeaderValue
            ? hideAuthInformation(request.authHeaderValue)
            : undefined;
        // NOTE: For security reasons, some registries respond with 404 on authentication errors as well.
        // So we print authorization info on 404 errors as well.
        if (response.status === 401 || response.status === 403 || response.status === 404) {
            hint = hint ? `${hint}\n\n` : '';
            if (authHeaderValue) {
                hint += `An authorization header was used: ${authHeaderValue}`;
            }
            else {
                hint += 'No authorization header was set for the request.';
            }
        }
        super(`FETCH_${response.status}`, message, { hint });
        this.request = request;
        this.response = response;
    }
}
exports.FetchError = FetchError;
function hideAuthInformation(authHeaderValue) {
    const [authType, token] = authHeaderValue.split(' ');
    return `${authType} ${token.substring(0, 4)}[hidden]`;
}
//# sourceMappingURL=index.js.map