"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const comver_to_semver_1 = __importDefault(require("comver-to-semver"));
const semver_1 = __importDefault(require("semver"));
function mergeLockfileChanges(ours, theirs) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const newLockfile = {
        importers: {},
        lockfileVersion: semver_1.default.gt(comver_to_semver_1.default(theirs.lockfileVersion.toString()), comver_to_semver_1.default(ours.lockfileVersion.toString()))
            ? theirs.lockfileVersion
            : ours.lockfileVersion,
    };
    for (const importerId of Array.from(new Set([...Object.keys(ours.importers), ...Object.keys(theirs.importers)]))) {
        newLockfile.importers[importerId] = {
            specifiers: {},
        };
        for (const key of ['dependencies', 'devDependencies', 'optionalDependencies']) {
            newLockfile.importers[importerId][key] = mergeDict((_b = (_a = ours.importers[importerId]) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : {}, (_d = (_c = theirs.importers[importerId]) === null || _c === void 0 ? void 0 : _c[key]) !== null && _d !== void 0 ? _d : {}, mergeVersions);
            if (Object.keys(newLockfile.importers[importerId][key]).length === 0) {
                delete newLockfile.importers[importerId][key];
            }
        }
        newLockfile.importers[importerId].specifiers = mergeDict((_f = (_e = ours.importers[importerId]) === null || _e === void 0 ? void 0 : _e.specifiers) !== null && _f !== void 0 ? _f : {}, (_h = (_g = theirs.importers[importerId]) === null || _g === void 0 ? void 0 : _g.specifiers) !== null && _h !== void 0 ? _h : {}, takeChangedValue);
    }
    const packages = {};
    for (const depPath of Array.from(new Set([...Object.keys((_j = ours.packages) !== null && _j !== void 0 ? _j : {}), ...Object.keys((_k = theirs.packages) !== null && _k !== void 0 ? _k : {})]))) {
        const ourPkg = (_l = ours.packages) === null || _l === void 0 ? void 0 : _l[depPath];
        const theirPkg = (_m = theirs.packages) === null || _m === void 0 ? void 0 : _m[depPath];
        const pkg = {
            ...ourPkg,
            ...theirPkg,
        };
        for (const key of ['dependencies', 'optionalDependencies']) {
            pkg[key] = mergeDict((_o = ourPkg === null || ourPkg === void 0 ? void 0 : ourPkg[key]) !== null && _o !== void 0 ? _o : {}, (_p = theirPkg === null || theirPkg === void 0 ? void 0 : theirPkg[key]) !== null && _p !== void 0 ? _p : {}, mergeVersions);
            if (Object.keys(pkg[key]).length === 0) {
                delete pkg[key];
            }
        }
        packages[depPath] = pkg;
    }
    newLockfile.packages = packages;
    return newLockfile;
}
exports.default = mergeLockfileChanges;
function mergeDict(ourDict, theirDict, valueMerger) {
    const newDict = {};
    for (const key of Object.keys(ourDict).concat(Object.keys(theirDict))) {
        const changedValue = valueMerger(ourDict[key], theirDict[key]);
        if (changedValue) {
            newDict[key] = changedValue;
        }
    }
    return newDict;
}
function takeChangedValue(ourValue, theirValue) {
    if (ourValue === theirValue || theirValue == null)
        return ourValue;
    return theirValue;
}
function mergeVersions(ourValue, theirValue) {
    if (ourValue === theirValue || !theirValue)
        return ourValue;
    if (!ourValue)
        return theirValue;
    const [ourVersion] = ourValue.split('_');
    const [theirVersion] = theirValue.split('_');
    if (semver_1.default.gt(ourVersion, theirVersion)) {
        return ourValue;
    }
    return theirValue;
}
//# sourceMappingURL=index.js.map