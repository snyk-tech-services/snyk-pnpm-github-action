#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = exports.makeApiCall = exports.displayResult = exports.buildNpmDepGraph = exports.getDepTree = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs = tslib_1.__importStar(require("fs"));
require("source-map-support/register");
const snyk_nodejs_lockfile_parser_ts_fork_1 = require("snyk-nodejs-lockfile-parser-ts-fork");
require("regenerator-runtime/runtime");
const dep_graph_1 = require("@snyk/dep-graph");
const path = tslib_1.__importStar(require("path"));
async function getDepTree(root, ManifestFilePath, includeDev, workspace) {
    const depTree = await snyk_nodejs_lockfile_parser_ts_fork_1.buildDepTreeFromFiles(root, ManifestFilePath, 'pnpm-lock.yaml', includeDev, false, workspace);
    depTree.type = 'npm';
    return depTree;
}
exports.getDepTree = getDepTree;
async function buildNpmDepGraph(root, ManifestFilePath, includeDev, workspace) {
    let depGraph;
    try {
        const depTree = getDepTree(root, ManifestFilePath, includeDev, workspace);
        const graph = await dep_graph_1.legacy.depTreeToGraph(await depTree, 'npm');
        depGraph = { depGraph: await graph };
    }
    catch (e) {
        throw new Error(`Fail to generate a depGraph ${e}`);
    }
    return depGraph;
}
exports.buildNpmDepGraph = buildNpmDepGraph;
function displayResult(resultArray) {
    resultArray.forEach((element) => {
        if (element.issues && (element.issues.length > 0)) {
            console.log(`****************** Vulnerabilities found! ******************\n`);
            // Todo: better display
            console.log(JSON.stringify(element));
        }
        else {
            console.log(`****************** No vulnerabilities found! ******************\n`);
            // Todo: better display
            console.log(JSON.stringify(element));
        }
    });
    return;
}
exports.displayResult = displayResult;
async function makeApiCall(depGraphArray, snykToken, orgId) {
    const baseUrl = 'https://snyk.io/api/v1/test/dep-graph?';
    const requestHeaders = {
        'Content-Type': 'application/json; charset=utf-8',
        'Authorization': `token ${snykToken}`,
    };
    const snykApiClient = axios_1.default.create({
        baseURL: baseUrl,
        responseType: 'json',
        headers: { ...requestHeaders },
    });
    const snykApiUrl = baseUrl + orgId;
    // eslint-disable-next-line prefer-const
    const resultArray = [];
    await Promise.all(depGraphArray.map(async (element) => {
        const response = await snykApiClient.post(snykApiUrl, JSON.stringify(element));
        resultArray.push(response.data);
    }));
    return resultArray;
}
exports.makeApiCall = makeApiCall;
function findJsonPackages(root, element) {
    let packagePath = path.resolve(root, element);
    if (element.includes('*')) {
        if (element.substring(element.length - 1) === '*') {
            element = element.slice(0, -2);
            packagePath = path.resolve(root, element);
        }
        if (element.includes('/*/')) {
            packagePath = path.resolve(root, element.split('/*/')[0], element.split('/*/')[1]);
        }
    }
    const fileObjs = fs.readdirSync(packagePath, { withFileTypes: true });
    const packagePathList = [];
    const packagePathToUse = packagePath.slice(root.length + 1);
    fileObjs.map(file => {
        if (file.isDirectory()) {
            packagePathList.push(packagePathToUse + '/' + file.name);
        }
        else if (file.name === 'package.json') {
            packagePathList.push(packagePathToUse);
        }
    });
    return packagePathList;
}
async function main() {
    let exitCode = 1;
    try {
        if (process.argv.length < 8) {
            console.log('Error, missing argument\n use --help to display the options');
            process.exit(2);
        }
        const options = process.argv;
        let root = '';
        let orgId = '';
        let snykToken = '';
        let includeDev = false;
        options.forEach((option, index) => {
            if (option === '--root') {
                root = options[index + 1];
            }
            else if (option === '--orgId') {
                orgId = options[index + 1];
            }
            else if (option === '--snykToken') {
                snykToken = options[index + 1];
            }
            else if (option === '--includeDev') {
                if (options[index + 1] === 'true') {
                    includeDev = true;
                }
            }
            else if (option === '--help') {
                const help = `
        --root: root path of the project
        --orgId: Organisation id to use for testing
        --snykToken: SNYK_API token
        --includeDev: true or false - include dev dependencies when building the depGraph - default to false
        `;
                console.log(help);
                process.exit(2);
            }
        });
        const LockFilePath = root + '/pnpm-lock.yaml';
        const PackageJsonPath = root + '/package.json';
        const WorkspaceFile = root + '/pnpm-workspace.yaml';
        if (!fs.existsSync(LockFilePath)) {
            throw new Error(`lockfile not found at location: ${LockFilePath}`);
        }
        if (!fs.existsSync(PackageJsonPath)) {
            throw Error(`package.json not found at location: ${PackageJsonPath}`);
        }
        const depGraphArray = [];
        if (fs.existsSync(WorkspaceFile)) {
            const packagesList = snyk_nodejs_lockfile_parser_ts_fork_1.getPnpmWorkspacesFromFiles(root, 'pnpm-workspace.yaml');
            if (packagesList) {
                //await Promise.allSettled(packagesList.map(async (element: string) => {
                for (let index = 0; index < packagesList.length; index++) {
                    const element = packagesList[index];
                    if (element[0] === '!') {
                        continue;
                    }
                    const manifestFilePathArray = findJsonPackages(root, element);
                    for (let i = 0; i < manifestFilePathArray.length; i++) {
                        const packagesManifestFilePath = manifestFilePathArray[i];
                        const manifestFilePath = packagesManifestFilePath + '/package.json';
                        const manifestFileFullPath = root + '/' + manifestFilePath;
                        if (!fs.existsSync(manifestFileFullPath)) {
                            throw new Error(`package.json not found at location: ${manifestFileFullPath}`);
                        }
                        // Change package manager
                        const depGraph = await buildNpmDepGraph(root, manifestFilePath, includeDev ? includeDev : false, packagesManifestFilePath);
                        depGraphArray.push(depGraph);
                    }
                    ;
                }
                ;
            }
        }
        else {
            depGraphArray.push(await buildNpmDepGraph(root, 'package.json', (includeDev ? includeDev : false)));
        }
        const responseArray = await makeApiCall(depGraphArray, snykToken, orgId);
        displayResult(responseArray);
        for (let index = 0; index < responseArray.length; index++) {
            if ((responseArray[index].issues) && (responseArray[index].issues.length > 0)) {
                exitCode = 1;
                break;
            }
            else {
                exitCode = 0;
            }
        }
        ;
        return { "exitCode": exitCode, "scanResult": responseArray };
    }
    catch (err) {
        throw new Error(err);
    }
}
exports.main = main;
if (!module.parent) {
    main();
}
//# sourceMappingURL=index.js.map