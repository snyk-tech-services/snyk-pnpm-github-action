#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = exports.makeApiCall = exports.displayResult = exports.buildNpmDepGraph = exports.getDepTree = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs = tslib_1.__importStar(require("fs"));
require("source-map-support/register");
const snyk_nodejs_lockfile_parser_ts_fork_1 = require("snyk-nodejs-lockfile-parser-ts-fork");
require("regenerator-runtime/runtime");
const dep_graph_1 = require("@snyk/dep-graph");
const debug_1 = tslib_1.__importDefault(require("debug"));
const globby = require("globby");
async function getDepTree(root, ManifestFilePath, includeDev, workspace) {
    const depTree = await snyk_nodejs_lockfile_parser_ts_fork_1.buildDepTreeFromFiles(root, ManifestFilePath, 'pnpm-lock.yaml', includeDev, false, workspace);
    depTree.type = 'npm';
    return depTree;
}
exports.getDepTree = getDepTree;
async function buildNpmDepGraph(root, ManifestFilePath, includeDev, workspace) {
    let depGraph;
    try {
        const depTree = getDepTree(root, ManifestFilePath, includeDev, workspace);
        const graph = await dep_graph_1.legacy.depTreeToGraph(await depTree, 'npm');
        depGraph = { depGraph: await graph };
    }
    catch (e) {
        throw new Error(`Fail to generate a depGraph ${e}`);
    }
    return depGraph;
}
exports.buildNpmDepGraph = buildNpmDepGraph;
function displayResult(resultArray) {
    resultArray.forEach((element) => {
        if (element.issues && (element.issues.length > 0)) {
            console.log(`****************** Vulnerabilities found! ******************\n`);
            // Todo: better display
            console.log(JSON.stringify(element));
        }
        else {
            console.log(`****************** No vulnerabilities found! ******************\n`);
            // Todo: better display
            console.log(JSON.stringify(element));
        }
    });
    return;
}
exports.displayResult = displayResult;
async function makeApiCall(depGraphArray, snykToken, orgId) {
    const baseUrl = 'https://snyk.io/api/v1/test/dep-graph?';
    const requestHeaders = {
        'Content-Type': 'application/json; charset=utf-8',
        'Authorization': `token ${snykToken}`,
    };
    const snykApiClient = axios_1.default.create({
        baseURL: baseUrl,
        responseType: 'json',
        headers: { ...requestHeaders },
    });
    const snykApiUrl = baseUrl + orgId;
    // eslint-disable-next-line prefer-const
    const resultArray = [];
    await Promise.all(depGraphArray.map(async (element) => {
        const response = await snykApiClient.post(snykApiUrl, JSON.stringify(element));
        resultArray.push(response.data);
    }));
    return resultArray;
}
exports.makeApiCall = makeApiCall;
async function findJsonPackages(root, element) {
    const debug = debug_1.default('Snyk');
    debug('element', element);
    const newElementArray = element.split('/');
    const ElementArray = [];
    newElementArray.forEach(el => {
        if (el.includes('*') === false && el.length > 0) {
            ElementArray.push(el);
        }
    });
    debug('ElementArray : ', ElementArray);
    const paths = await globby(root, {
        expandDirectories: {
            files: ['package.json']
        }
    });
    debug("paths: ", paths);
    const newPackagePath = [];
    paths.map(path => {
        let isInPath = true;
        ElementArray.forEach(el => {
            if (path.includes(el) === false) {
                isInPath = false;
                return;
            }
            const newPathList = path.split('/');
            if (newPathList.indexOf(el) === -1) {
                isInPath = false;
                return;
            }
        });
        if (isInPath) {
            const newpath = ElementArray[0] + path.split(ElementArray[0])[1]; // remove root
            const newPathList = newpath.split('/');
            newPathList.pop(); // remove package.json
            const newPath = newPathList.join('/');
            if (newPathList) {
                newPackagePath.push(newPath);
            }
        }
    });
    debug("PackagePathList: ", newPackagePath);
    return newPackagePath;
}
async function main() {
    const debug = debug_1.default('Snyk');
    let exitCode = 1;
    try {
        const options = process.argv;
        let root = '';
        let manifestFilePath = '';
        let orgId = '';
        let snykToken = '';
        let includeDev = false;
        options.forEach((option, index) => {
            if (option === '--root') {
                root = options[index + 1];
            }
            else if (option === '--orgId') {
                orgId = options[index + 1];
            }
            else if (option === '--snykToken') {
                snykToken = options[index + 1];
            }
            else if (option === '--includeDev') {
                if (options[index + 1] === 'true') {
                    includeDev = true;
                }
            }
            else if (option === '--manifestFilePath') {
                manifestFilePath = options[index + 1];
            }
            else if (option === '--help') {
                const help = `
        --root: root path of the project (lockfile)
        --orgId: Organization id to use for testing
        --snykToken: SNYK_API token
        --includeDev: true or false - include dev dependencies when building the depGraph - default to false
        --manifestFilePath: path to the manifest file, not needed if the lockfile and the manifest file are in the same folder`;
                console.log(help);
                process.exit(2);
            }
        });
        if (process.argv.length < 8) {
            console.log('Error, missing argument\n use --help to display the options');
            process.exit(2);
        }
        const LockFilePath = root + '/pnpm-lock.yaml';
        let PackageJsonPath = root + '/package.json';
        const WorkspaceFile = root + '/pnpm-workspace.yaml';
        if (manifestFilePath.length > 0) {
            PackageJsonPath = manifestFilePath + '/package.json';
        }
        debug('LockFilePath: ', LockFilePath);
        debug('PackageJsonPath: ', PackageJsonPath);
        debug('WorkspaceFile: ', WorkspaceFile);
        if (!fs.existsSync(LockFilePath)) {
            throw new Error(`lockfile not found at location: ${LockFilePath}`);
        }
        if (!fs.existsSync(PackageJsonPath)) {
            throw Error(`package.json not found at location: ${PackageJsonPath}`);
        }
        const depGraphArray = [];
        if (fs.existsSync(WorkspaceFile)) {
            debug('workspace project');
            const packagesList = snyk_nodejs_lockfile_parser_ts_fork_1.getPnpmWorkspacesFromFiles(root, 'pnpm-workspace.yaml');
            if (packagesList) {
                for (let index = 0; index < packagesList.length; index++) {
                    const element = packagesList[index];
                    if (element[0] === '!') {
                        continue;
                    }
                    const manifestFilePathArray = await findJsonPackages(root, element);
                    for (let i = 0; i < manifestFilePathArray.length; i++) {
                        const packagesManifestFilePath = manifestFilePathArray[i];
                        const manifestFilePath = packagesManifestFilePath + '/package.json';
                        const manifestFileFullPath = root + '/' + manifestFilePath;
                        if (!fs.existsSync(manifestFileFullPath)) {
                            throw new Error(`package.json not found at location: ${manifestFileFullPath}`);
                        }
                        debug('creating depGraph');
                        debug('manifestFilePath: ', manifestFilePath);
                        debug('packagesManifestFilePath: ', packagesManifestFilePath);
                        debug('root: ', root);
                        // Change package manager
                        const depGraph = await buildNpmDepGraph(root, manifestFilePath, includeDev ? includeDev : false, packagesManifestFilePath);
                        depGraphArray.push(depGraph);
                    }
                    ;
                }
                ;
            }
        }
        else {
            depGraphArray.push(await buildNpmDepGraph(root, PackageJsonPath, (includeDev ? includeDev : false)));
        }
        const responseArray = await makeApiCall(depGraphArray, snykToken, orgId);
        displayResult(responseArray);
        for (let index = 0; index < responseArray.length; index++) {
            if ((responseArray[index].issues) && (responseArray[index].issues.length > 0)) {
                exitCode = 1;
                break;
            }
            else {
                exitCode = 0;
            }
        }
        ;
        return { "exitCode": exitCode, "scanResult": responseArray };
    }
    catch (err) {
        throw new Error(err);
    }
}
exports.main = main;
if (!module.parent) {
    main();
}
//# sourceMappingURL=index.js.map